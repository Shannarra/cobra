using System;
using System.Collections.Generic;

namespace Cobra.CodeDom.Syntax
{
    /// <summary>
    /// Provides an abstraction for a parsing mechanism
    /// </summary>
    internal sealed class Parser
    {
        /// <summary>
        /// Array of the lex-ed tokens
        /// </summary>
        private readonly SyntaxToken[] tokens;

        /// <summary>
        /// The current element parsing position
        /// </summary>
        private int position;

        private readonly List<string> errors = new List<string>();
        
        /// <summary>
        /// List of all errors generated by both the <see cref="Lexer"/> and <see cref="Parser"/>
        /// </summary>
        public IReadOnlyList<string> Errors => errors;

        /// <summary>
        /// Initializes parsing by a given <paramref name="text"/>
        /// </summary>
        /// <param name="text">The text to parse</param>
        public Parser(string text)
        {
            var lexer = new Lexer(text);
            var tokens = new List<SyntaxToken>();

            SyntaxToken token;

            do
            {
                token = lexer.Lex();

                if (token.Kind != SyntaxKind.WhiteSpace &&
                    token.Kind != SyntaxKind.Error)
                    tokens.Add(token);
            } while (token.Kind != SyntaxKind.EndOfFile);

            this.tokens = tokens.ToArray();
            errors.AddRange(lexer.Errors);
        }

        /// <summary>
        /// Advances the position to the nex token
        /// </summary>
        /// <returns>The current token</returns>
        private SyntaxToken NextToken()
        {
            var curr = Current;
            position++;
            return curr;
        }

        /// <summary>
        /// Matches the <see cref="Current"/> token with a given <paramref name="kind"/>
        /// </summary>
        /// <param name="kind">The <see cref="SyntaxKind"/> to look for</param>
        /// <returns></returns>
        private SyntaxToken MatchToken(SyntaxKind kind)
        {
            if (Current.Kind == kind)
                return NextToken();

            errors.Add($"[ERROR]: Unexpected token [{Current.Kind}], expected [{kind}]");
            return new SyntaxToken(kind, Current.Position, null, null);
        }

        /// <summary>
        /// Allows "peeking" ahead of the current position without modifying it
        /// </summary>
        /// <param name="offset">How far to look?</param>
        /// <returns></returns>
        private SyntaxToken LookAhead(int offset)
        {
            var index = position + offset;

            return index >= tokens.Length ? tokens[^1] : tokens[index];
        }

        private SyntaxToken Current => LookAhead(0);

        /// <summary>
        /// Starts parsing the already created <see cref="tokens"/> with the <see cref="Current"/> one
        /// </summary>
        /// <returns></returns>
        public SyntaxTree Parse()
        {
            var exp = ParseExpression();
            // if for example we pass "1 1", we expect "1 + 1", or just "1 \0", so we get an error - expected EOF
            var eofToken = MatchToken(SyntaxKind.EndOfFile); 
            return new SyntaxTree(errors, exp, eofToken);
        }

        private Expression ParseExpression(int priority = 0)
        {
            Expression left;

            var unaryPresent = Current.Kind.GetUnaryOperatorPriority();

            if (unaryPresent != 0 && unaryPresent >= priority)
            {
                var operatorToken = NextToken();
                
                var operand = ParseExpression(unaryPresent);
                left = new UnaryOperationExpressionSyntax(operatorToken, operand);
            }
            else
                left = ParsePrimary();

            while (true)
            {
                var present = Current.Kind.GetBinaryOperatorPriority();
                if (present == 0 || present <= priority)
                    break;

                var operatorToken = NextToken();
                var right = ParseExpression(present);
                left = new BinaryOperationExpressionSyntax(left, operatorToken, right);
            }

            return left;
        }

        /// <summary>
        /// Parses a primary (first-order) expression
        /// </summary>
        /// <returns></returns>
        private Expression ParsePrimary()
        {
            switch (Current.Kind)
            {
                case SyntaxKind.ParenthesisOpen:
                {
                    var left = NextToken();
                    var expr = ParseExpression();
                    var right = MatchToken(SyntaxKind.ParenthesisClose);
                    return new ParenthesizedExpression(left, expr, right);
                }
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                {
                    var keyword = NextToken(); // ALWAYS CONSUME TOKENS!
                    var value = Current.Kind == SyntaxKind.TrueKeyword;
                    return new LiteralExpressionSyntax(keyword, value);
                }
                default:
                {
                    var numToken = MatchToken(SyntaxKind.Number);
                    return new LiteralExpressionSyntax(numToken);
                }
            }
        }

    }
}
