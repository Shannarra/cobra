using System.Collections.Generic;

namespace Cobra.Syntax
{
    /// <summary>
    /// Provides an abstraction for a parsing mechanism
    /// </summary>
    internal sealed class Parser
    {
        /// <summary>
        /// Array of the lex-ed tokens
        /// </summary>
        private readonly SyntaxToken[] tokens;

        /// <summary>
        /// The current element parsing position
        /// </summary>
        private int position;

        private readonly List<string> errors = new List<string>();
        
        /// <summary>
        /// List of all errors generated by both the <see cref="Lexer"/> and <see cref="Parser"/>
        /// </summary>
        public IReadOnlyList<string> Errors => errors;

        /// <summary>
        /// Initializes parsing by a given <paramref name="text"/>
        /// </summary>
        /// <param name="text">The text to parse</param>
        public Parser(string text)
        {
            var lexer = new Lexer(text);
            var tokens = new List<SyntaxToken>();

            SyntaxToken token;

            do
            {
                token = lexer.Lex();

                if (token.Kind != SyntaxKind.WhiteSpace &&
                    token.Kind != SyntaxKind.Error)
                    tokens.Add(token);
            } while (token.Kind != SyntaxKind.EndOfFile);

            this.tokens = tokens.ToArray();
            errors.AddRange(lexer.Errors);
        }

        /// <summary>
        /// Advances the position to the nex token
        /// </summary>
        /// <returns>The current token</returns>
        private SyntaxToken NextToken()
        {
            var curr = Current;
            position++;
            return curr;
        }

        /// <summary>
        /// Matches the <see cref="Current"/> token with a given <paramref name="kind"/>
        /// </summary>
        /// <param name="kind">The <see cref="SyntaxKind"/> to look for</param>
        /// <returns></returns>
        private SyntaxToken MatchToken(SyntaxKind kind)
        {
            if (Current.Kind == kind)
                return NextToken();

            errors.Add($"[ERROR]: Unexpected token [{Current.Kind}], expected [{kind}]");
            return new SyntaxToken(kind, Current.Position, null, null);
        }

        /// <summary>
        /// Allows "peeking" ahead of the current position without modifying it
        /// </summary>
        /// <param name="offset">How far to look?</param>
        /// <returns></returns>
        private SyntaxToken LookAhead(int offset)
        {
            var index = position + offset;

            return index >= tokens.Length ? tokens[^1] : tokens[index];
        }

        private SyntaxToken Current => LookAhead(0);

        /// <summary>
        /// Starts parsing the already created <see cref="tokens"/> with the <see cref="Current"/> one
        /// </summary>
        /// <returns></returns>
        public SyntaxTree Parse()
        {
            var exp = ParseTermExpression();
            // if for example we pass "1 1", we expect "1 + 1", or just "1 \0", so we get an error - expected EOF
            var eofToken = MatchToken(SyntaxKind.EndOfFile); 
            return new SyntaxTree(errors, exp, eofToken);
        }
        
        /// <summary>
        /// Parses a primary (first-order) expression
        /// </summary>
        /// <returns></returns>
        private Expression ParsePrimary()
        {
            if (Current.Kind == SyntaxKind.ParenthesisOpen)
            {
                var left = NextToken();
                var expr = ParseTermExpression();
                var right = MatchToken(SyntaxKind.ParenthesisClose);
                return new ParenthesizedExpression(left, expr, right);
            }

            var numToken = MatchToken(SyntaxKind.Number);
            return new LiteralExpressionSyntax(numToken);
        }

        /// <summary>
        /// Parses a term (-,+) expression
        /// </summary>
        /// <returns></returns>
        public Expression ParseTermExpression()
        {
            var left = ParseMultiplicationExpression();

            while (Current.Kind == SyntaxKind.Plus ||
                   Current.Kind == SyntaxKind.Minus)
            {
                var operatorToken = NextToken(); // we must have an operator here
                var right = ParseMultiplicationExpression();
                left = new BinaryOperationExpressionSyntax(left, operatorToken, right);
            }

            return left;
        }
        
        /// <summary>
        /// Parses multiplication (factor) expression
        /// </summary>
        /// <returns></returns>
        public Expression ParseMultiplicationExpression()
        {
            var left = ParsePrimary();

            while (Current.Kind == SyntaxKind.Star ||
                   Current.Kind == SyntaxKind.Slash)
            {
                var operatorToken = NextToken(); // we must have an operator here
                var right = ParsePrimary();
                left = new BinaryOperationExpressionSyntax(left, operatorToken, right);
            }

            return left;
        }
    }
}
